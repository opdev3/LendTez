<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>contract API documentation</title>
<meta name="description" content="This project is intended to provide an easy and efficient way to lend and/or borrow tokens and XTZ on Tezos blockchain â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>contract</code></h1>
</header>
<section id="section-intro">
<p>This project is intended to provide an easy and efficient way to lend and/or borrow tokens and XTZ on Tezos blockchain.</p>
<p><small>Built with SmartPy 0.14.0</small></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This project is intended to provide an easy and efficient way to lend and/or borrow tokens and XTZ on Tezos blockchain.

&lt;small&gt;Built with SmartPy 0.14.0&lt;/small&gt;
&#34;&#34;&#34;

import smartpy as sp


class Error:
    &#34;&#34;&#34;The enum used for the contract related errors.&#34;&#34;&#34;

    ACCESS_DENIED = &#34;ERR_ACCESS_DENIED&#34;
    &#34;&#34;&#34;The contract function is not accessible for the sender.&#34;&#34;&#34;

    ILLEGAL_ARGUMENT = &#34;ERR_ILLEGAL_ARGUMENT&#34;
    &#34;&#34;&#34;The corresponding argument value is invalid.&#34;&#34;&#34;

    ILLEGAL_TX_AMOUNT = &#34;ERR_ILLEGAL_TX_AMOUNT&#34;
    &#34;&#34;&#34;The corresponding transaction has incorrect tezos amount.&#34;&#34;&#34;

    PAUSED = &#34;ERR_PAUSED&#34;
    &#34;&#34;&#34;The contract is paused.&#34;&#34;&#34;



class TokenType:
    &#34;&#34;&#34;The enum used for the contract token types.&#34;&#34;&#34;

    XTZ  = sp.nat(0)
    &#34;&#34;&#34;Native Tezos token.&#34;&#34;&#34;

    FA12 = sp.nat(1)
    &#34;&#34;&#34;Fungible Asset (FA1.2).&#34;&#34;&#34;

    FA20 = sp.nat(2)
    &#34;&#34;&#34;Multi-Asset (FA2).&#34;&#34;&#34;



# Token structure.
# 
TToken = sp.TRecord(
    name = sp.TString,       # token name
    address = sp.TAddress,   # token address
    type = sp.TNat,          # token type: TokenType.XTZ or TokenType.FA12 or TokenType.FA20
    token_id = sp.TNat,      # token id
    decimals = sp.TNat,      # decimals
)



def transfer_tokens(sender, receiver, amount, token):
    &#34;&#34;&#34;Help function to transfer tokens.

    Args:
        sender (address): source address
        receiver (address): destination address
        amount (nat): amount of tokens
        token_id (nat): deposit token ID
        token (TToken): token information
    &#34;&#34;&#34;
    with sp.if_((token.type == TokenType.FA12)):
        param_values = sp.record(from_ = sender, to_ = receiver, value = amount)
        param_type = sp.TRecord(from_ = sp.TAddress, to_ = sp.TAddress, value = sp.TNat).layout((&#34;from_ as from&#34;, (&#34;to_ as to&#34;, &#34;value&#34;)))
        sp.transfer(param_values, sp.mutez(0), sp.contract(param_type, token.address, entry_point=&#34;transfer&#34;).open_some())
    with sp.else_():
        param_values = [sp.record(from_ = sender, txs = [sp.record(to_ = receiver, token_id = token.token_id, amount = amount)])]
        param_type = sp.TList(sp.TRecord(from_ = sp.TAddress, txs = sp.TList(sp.TRecord(amount = sp.TNat, to_ = sp.TAddress, token_id = sp.TNat).layout((&#34;to_&#34;, (&#34;token_id&#34;, &#34;amount&#34;))))))
        sp.transfer(param_values, sp.mutez(0), sp.contract(param_type, token.address, entry_point=&#39;transfer&#39;).open_some())



class LendTez(sp.Contract):
    &#34;&#34;&#34;The contract is a storage for p2p credit deals and provides service functionality to make such deals.

    There is the storage:
    Args:
        pause (bool): indicates that creating loan requests and making credit deals is disabled
        baker (option): baker address or _None_
        admins (set): list of admin addresses
        time (pair): time bounds for credit deals
        ntoken (nat): last token ID
        tokens (big_map): supported tokens (key is token ID)
        nloan (nat): last loan request ID
        loans (big_map): map of loan requests (key is loan request ID)
        ndeal (nat): last credit deal ID
        deals (big_map): map of credit deals (key is credit deal ID)
    &#34;&#34;&#34;

    def __init__(self, creator):
        self.creator = creator

        self.init(
            pause = False,
            baker = sp.none,
            admins = sp.set([creator]),
            time = sp.record(min = sp.nat(7 * 86400), max = sp.nat(180 * 86400)),
            ntoken = sp.nat(0),
            tokens = sp.big_map(),
            nloan = sp.nat(0),
            loans = sp.big_map(),
            ndeal = sp.nat(0),
            deals = sp.big_map(),
        )


    @sp.entry_point
    def default(self):
        &#34;&#34;&#34;Support tezos transfer to the contract address.&#34;&#34;&#34;
        pass


    @sp.entry_point
    def withdraw(self, params):
        &#34;&#34;&#34;(Admins only) Transfer XTZ (except locked collateral) from the contract address.
        
        Args:
            to (address): destination address
            id (nat): token ID of XTZ
            amount (mutez): XTZ amount
        Raises:
            `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.to, sp.TAddress)
        sp.set_type(params.id, sp.TNat)
        sp.set_type(params.amount, sp.TNat)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.tokens.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        sp.verify(self.data.tokens[params.id].type == TokenType.XTZ, message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        sp.verify(params.amount &gt; 0, message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
        sp.verify(sp.utils.mutez_to_nat(sp.balance) &gt;= (self.data.tokens[params.id].locked_amount + params.amount), message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
        sp.send(params.to, sp.utils.nat_to_mutez(params.amount))


    @sp.entry_point
    def add_admin(self, params):
        &#34;&#34;&#34;(Admins only) Add an admin address to the list of admin addresses.
        
        Args:
            address (address): new admin address
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.address, sp.TAddress)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(~self.data.admins.contains(params.address), message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
        self.data.admins.add(params.address)


    @sp.entry_point
    def remove_admin(self, params):
        &#34;&#34;&#34;(Admins only) Remove an admin address from the list of admin addresses.

        Args:
            address (address): admin address
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.address, sp.TAddress)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.creator != params.address, message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
        sp.verify(self.data.admins.contains(params.address), message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
        self.data.admins.remove(params.address)


    @sp.entry_point
    def delegate(self, params):
        &#34;&#34;&#34;(Admins only) Set a baker for the contract.

        Args:
            baker (option): baker address or _None_
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.baker, sp.TOption(sp.TKeyHash))
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.baker != params.baker, message = Error.ILLEGAL_ARGUMENT + &#34;:baker&#34;)
        self.data.baker = params.baker
        sp.set_delegate(params.baker)


    @sp.entry_point
    def pause(self, params):
        &#34;&#34;&#34;(Admins only) Disable/enable making of new loan requests and new deals.

        Args:
            pause (bool): _True_ or _False_
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.pause, sp.TBool)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.pause != params.pause, message = Error.ILLEGAL_ARGUMENT + &#34;:pause&#34;)
        self.data.pause = params.pause


    @sp.entry_point
    def set_time(self, params):
        &#34;&#34;&#34;(Admins only) Set time bounds for credit deals.

        Args:
            min (nat): minimum deal duration in seconds
            max (nat): maximum deal duration in seconds
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params, sp.TRecord(min = sp.TNat, max = sp.TNat))
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.time != params, message = Error.ILLEGAL_ARGUMENT + &#34;:min,max&#34;)
        sp.verify((params.min &gt; 0) &amp; (params.min &lt;= params.max), message = Error.ILLEGAL_ARGUMENT + &#34;:min&#34;)
        self.data.time = params


    @sp.entry_point
    def add_token(self, params):
        &#34;&#34;&#34;(Admins only) Add supported token.

        Args:
            name (string): token name
            address (address): token address
            type (nat): token type (TokenType.XTZ or TokenType.FA12 or TokenType.FA20)
            token_id (nat): token id for the corresponding token address
            decimals (nat): decimals
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params, TToken)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify((params.type == TokenType.XTZ) | (params.type == TokenType.FA12) | (params.type == TokenType.FA20), message = Error.ILLEGAL_ARGUMENT + &#34;:type&#34;)
        self.data.tokens[self.data.ntoken] = sp.record(
            name = params.name,
            address = params.address,
            type = params.type,
            token_id = params.token_id,
            decimals = params.decimals,
            locked_amount = 0,
            active = True
        )
        self.data.ntoken += 1


    @sp.entry_point
    def set_token_active(self, params):
        &#34;&#34;&#34;(Admins only) Set active status for supported token.

        Args:
            id (nat): token id
            active (bool): active status (a token can not be a part of a loan request if active=_False_)
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.id, sp.TNat)
        sp.set_type(params.active, sp.TBool)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.tokens.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        sp.verify(self.data.tokens[params.id].active != params.active, message = Error.ILLEGAL_ARGUMENT + &#34;:active&#34;)
        self.data.tokens[params.id].active = params.active


    @sp.entry_point
    def add_loan(self, params):
        &#34;&#34;&#34;Create a new loan request.
        
        The corresponding transaction amount has to include deposit, if the deposit is XTZ.

        Args:
            loan_token_id (nat): loan token ID
            loan_amount (nat): requested amount of tokens
            reward (nat): amount of tokens as creditor&#39;s reward 
            deposit_token_id (nat): deposit token ID
            deposit_amount (nat): deposit amount of tokens
            time (nat): credit deal duration in seconds
            validity (option): loan request expire date or None
        Raises:
            `OD_PAUSED`, `OD_ILLEGAL_TX_AMOUNT`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.loan_token_id, sp.TNat)
        sp.set_type(params.loan_amount, sp.TNat)
        sp.set_type(params.reward, sp.TNat)
        sp.set_type(params.deposit_token_id, sp.TNat)
        sp.set_type(params.deposit_amount, sp.TNat)
        sp.set_type(params.time, sp.TNat)
        sp.set_type(params.validity, sp.TOption(sp.TTimestamp))
        sp.verify(~self.data.pause, message = Error.PAUSED)
        sp.verify(self.data.tokens.contains(params.loan_token_id), message = Error.ILLEGAL_ARGUMENT + &#34;:loan_token_id&#34;)
        sp.verify(self.data.tokens[params.loan_token_id].active, message = Error.ILLEGAL_ARGUMENT + &#34;:loan_token&#34;)
        sp.verify(params.loan_amount &gt; 0, message = Error.ILLEGAL_ARGUMENT + &#34;:loan_amount&#34;)
        sp.verify(params.loan_token_id != params.deposit_token_id , message = Error.ILLEGAL_ARGUMENT + &#34;:deposit_token&#34;)
        sp.verify(self.data.tokens.contains(params.deposit_token_id), message = Error.ILLEGAL_ARGUMENT + &#34;:deposit_token_id&#34;)
        sp.verify(self.data.tokens[params.deposit_token_id].active, message = Error.ILLEGAL_ARGUMENT + &#34;:deposit_token&#34;)
        sp.verify((params.time &gt;= self.data.time.min) &amp; (params.time &lt;= self.data.time.max), message = Error.ILLEGAL_ARGUMENT + &#34;:time&#34;)
        sp.verify((params.validity == sp.none) | (params.validity &gt; sp.some(sp.now)), message = Error.ILLEGAL_ARGUMENT + &#34;:validity&#34;)

        deposit_token = sp.local(&#34;deposit_token&#34;, self.data.tokens[params.deposit_token_id])
        with sp.if_((deposit_token.value.type == TokenType.XTZ)):
            sp.verify(params.deposit_amount == sp.utils.mutez_to_nat(sp.amount), message = Error.ILLEGAL_TX_AMOUNT)
        with sp.else_():
            sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
            with sp.if_((params.deposit_amount &gt; 0)):
                transfer_tokens(sender = sp.sender, receiver = sp.self_address, amount = params.deposit_amount, token = deposit_token.value)
        self.data.tokens[params.deposit_token_id].locked_amount += params.deposit_amount
        self.data.nloan += 1
        self.data.loans[self.data.nloan] = sp.record(
            ts = sp.now,
            borrower = sp.sender,
            loan_token_id = params.loan_token_id,
            loan_amount = params.loan_amount,
            reward = params.reward,
            deposit_token_id = params.deposit_token_id,
            deposit_amount = params.deposit_amount,
            time = params.time,
            validity = params.validity
        )


    @sp.entry_point
    def cancel_loan(self, params):
        &#34;&#34;&#34;Cancel sender&#39;s loan request, the deposit of the loan is returned to the sender.

        Args:
            id (nat): loan request ID
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.id, sp.TNat)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.loans.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        loan = sp.local(&#34;loan&#34;, self.data.loans[params.id])
        sp.verify((sp.sender == loan.value.borrower) | self.data.admins.contains(sp.sender), Error.ACCESS_DENIED)
        self.refund_deposit(receiver = loan.value.borrower, token_id = loan.value.deposit_token_id, amount = loan.value.deposit_amount)
        del self.data.loans[params.id]


    @sp.entry_point
    def make_deal(self, params):
        &#34;&#34;&#34;Make a credit deal, the sender has to approve the corresponding token transfer early.

        Args:
            id (nat): loan request ID
        Raises:
            `OD_PAUSED`, `OD_ILLEGAL_TX_AMOUNT`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.id, sp.TNat)
        sp.verify(~self.data.pause, message = Error.PAUSED)
        sp.verify(self.data.loans.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        loan = sp.local(&#34;loan&#34;, self.data.loans[params.id])
        sp.verify(loan.value.borrower != sp.sender, Error.ILLEGAL_ARGUMENT + &#34;:sender&#34;)
        sp.verify((loan.value.validity == sp.none) | (loan.value.validity &gt; sp.some(sp.now)), message = Error.ILLEGAL_ARGUMENT + &#34;:now&#34;)
        loan_token = sp.local(&#34;loan_token&#34;, self.data.tokens[loan.value.loan_token_id])
        with sp.if_((loan_token.value.type == TokenType.XTZ)):
            sp.verify(loan.value.loan_amount == sp.utils.mutez_to_nat(sp.amount), message = Error.ILLEGAL_TX_AMOUNT)
            sp.send(loan.value.borrower, sp.amount)
        with sp.else_():
            sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
            transfer_tokens(sender = sp.sender, receiver = loan.value.borrower, amount = loan.value.loan_amount, token = loan_token.value)
        self.data.ndeal += 1
        self.data.deals[self.data.ndeal] = sp.record(
            ts = sp.now,
            borrower = loan.value.borrower,
            creditor = sp.sender,
            loan_token_id = loan.value.loan_token_id,
            loan_amount = loan.value.loan_amount,
            reward = loan.value.reward,
            exp = sp.now.add_seconds(sp.to_int(loan.value.time)),
            deposit_token_id = loan.value.deposit_token_id,
            deposit_amount = loan.value.deposit_amount,
        )
        del self.data.loans[params.id]


    @sp.entry_point
    def close_deal(self, params):
        &#34;&#34;&#34;Close a deal by borrower or creditor/admins.

        If a deal is closed by borrower, the tokens are sent to the creditor and the borrower gets back the deposit;
        if a deal timed out and it&#39;s closed by the creditor or admins, the creditor gets the deposit.

        Args:
            id (nat): credit deal ID
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.id, sp.TNat)
        sp.verify(self.data.deals.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        deal = sp.local(&#34;deal&#34;, self.data.deals[params.id])
        sp.verify((sp.sender == deal.value.borrower) | (sp.sender == deal.value.creditor) | self.data.admins.contains(sp.sender), Error.ACCESS_DENIED)
        deposit_receiver = sp.local(&#39;deposit_receiver&#39;, sp.self_address)
        with sp.if_(sp.sender == deal.value.borrower):
            loan_token = sp.local(&#34;loan_token&#34;, self.data.tokens[deal.value.loan_token_id])
            with sp.if_((loan_token.value.type == TokenType.XTZ)):
                sp.verify((deal.value.loan_amount + deal.value.reward) == sp.utils.mutez_to_nat(sp.amount), message = Error.ILLEGAL_TX_AMOUNT)
                sp.send(deal.value.creditor, sp.amount)
            with sp.else_():
                sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
                transfer_tokens(sender = deal.value.borrower, receiver = deal.value.creditor, amount = (deal.value.loan_amount + deal.value.reward), token = loan_token.value)
            deposit_receiver.value = deal.value.borrower
        with sp.else_():
            sp.verify(deal.value.exp &lt; sp.now, message = Error.ACCESS_DENIED)
            deposit_receiver.value = deal.value.creditor
        self.refund_deposit(receiver = deposit_receiver.value, token_id = deal.value.deposit_token_id, amount = deal.value.deposit_amount)
        del self.data.deals[params.id]


    def refund_deposit(self, receiver, token_id, amount):
        &#34;&#34;&#34;Help function to send deposit.

        Args:
            receiver (address): destination address
            token_id (nat): deposit token ID
            amount (nat): deposit amount of tokens
        &#34;&#34;&#34;
        with sp.if_(amount &gt; 0):
            deposit_token = sp.local(&#34;deposit_token&#34;, self.data.tokens[token_id])
            with sp.if_((deposit_token.value.type == TokenType.XTZ)):
                sp.send(receiver, sp.utils.nat_to_mutez(amount))
            with sp.else_():
                transfer_tokens(sender = sp.self_address, receiver = receiver, amount = amount, token = deposit_token.value)
            self.data.tokens[token_id].locked_amount = sp.as_nat(self.data.tokens[token_id].locked_amount - amount)



#########################################################################################################

CREATOR_ADDRESS = &#34;tz1fE6hEiRFa9ZHJeZrccNKsGW7jdxfe9vcv&#34;

# Tests
@sp.add_test(name = &#34;LendTez&#34;)
def test():
    creator = sp.address(CREATOR_ADDRESS)
    admin = sp.test_account(&#34;Admin&#34;)
    userA = sp.test_account(&#34;UserA&#34;)
    userB = sp.test_account(&#34;UserB&#34;)
    userC = sp.test_account(&#34;UserC&#34;)
    DAY = 86400
    INITIAL_BALANCE = 1_000_000_000
    c1 = LendTez(creator)
    c1.set_initial_balance(sp.mutez(INITIAL_BALANCE))
    scenario = sp.test_scenario()
    scenario.h1(&#34;LendTez tests&#34;)
    scenario += c1


    scenario.h1(&#34;Admins&#34;)
    scenario.h2(&#34;add_admin()&#34;)
    c1.add_admin(address=userA.address).run(sender = creator, amount=sp.mutez(1), valid = False)
    c1.add_admin(address=userA.address).run(sender = userA, valid = False)
    c1.add_admin(address=admin.address).run(sender = creator)
    c1.add_admin(address=admin.address).run(sender = creator, valid = False)
    c1.add_admin(address=userA.address).run(sender = admin)
    scenario.h2(&#34;remove_admin()&#34;)
    c1.remove_admin(address=userA.address).run(sender = admin, amount=sp.mutez(1), valid = False)
    c1.remove_admin(address=admin.address).run(sender = userB, valid = False)
    c1.remove_admin(address=creator).run(sender = admin, valid = False)
    c1.remove_admin(address=userA.address).run(sender = admin)
    c1.remove_admin(address=userA.address).run(sender = admin, valid = False)


    scenario.h1(&#34;Delegate&#34;)
    scenario.h2(&#34;delegate()&#34;)
    keyHash = sp.key_hash(&#34;tz1fwnfJNgiDACshK9avfRfFbMaXrs3ghoJa&#34;)
    voting_powers = {keyHash : 0}
    c1.delegate(baker=sp.some(keyHash)).run(sender = admin, voting_powers = voting_powers, amount=sp.mutez(1), valid = False)
    c1.delegate(baker=sp.some(keyHash)).run(sender = userB, voting_powers = voting_powers, valid = False)
    c1.delegate(baker=sp.some(keyHash)).run(sender = admin, voting_powers = voting_powers)
    c1.delegate(baker=sp.some(keyHash)).run(sender = admin, voting_powers = voting_powers, valid = False)
    scenario.verify_equal(c1.baker, sp.some(keyHash))
    c1.delegate(baker=sp.none).run(sender = admin)


    scenario.h1(&#34;Time&#34;)
    scenario.h2(&#34;set_time()&#34;)
    c1.set_time(sp.record(min=1*DAY, max=366*DAY)).run(sender = creator, amount=sp.mutez(1), valid = False)
    c1.set_time(sp.record(min=3*DAY, max=60*DAY)).run(sender = userA, valid = False)
    c1.set_time(sp.record(min=0*DAY, max=366*DAY)).run(sender = creator, valid = False)
    c1.set_time(sp.record(min=180*DAY, max=7*DAY)).run(sender = creator, valid = False)
    c1.set_time(sp.record(min=1*DAY, max=366*DAY)).run(sender = admin)
    c1.set_time(sp.record(min=1*DAY, max=366*DAY)).run(sender = creator, valid = False)


    scenario.h1(&#34;Tokens&#34;)
    tXTZ = sp.record(name=&#34;XTZ&#34;, address=c1.address, type=0, token_id=0, decimals=6)
    tBTC = sp.record(name=&#34;_BTC&#34;, address=sp.address(&#34;tz1oBTCoMEtsXm3QxA7FmMU2Qh7xzsUoBTCo&#34;), type=1, token_id=0, decimals=8)
    tETH = sp.record(name=&#34;_ETH&#34;, address=sp.address(&#34;tz1oETHo1otsXm3QxA7FmMU2Qh7xzsGoETHo&#34;), type=1, token_id=0, decimals=18)
    tXRP = sp.record(name=&#34;_XRP&#34;, address=sp.address(&#34;tz1oXRPoMEtsXm3QxA7FmMU2Qh7xzsSoXRPo&#34;), type=1, token_id=0, decimals=12)
    fake_tBTC = sp.record(name=&#34;_BTC&#34;, address=tETH.address, type=1, token_id=0,  decimals=8)
    fake_tBTC_id=123
    scenario.h2(&#34;add_token()&#34;)
    c1.add_token(tBTC).run(sender = creator, amount=sp.mutez(1), valid = False)
    c1.add_token(tETH).run(sender = userA, valid = False)
    c1.add_token(tXTZ).run(sender = creator)
    tXTZ_id = 0
    c1.add_token(tBTC).run(sender = creator)
    tBTC_id = 1
    c1.add_token(tETH).run(sender = admin)
    tETH_id = 2
    c1.add_token(tXRP).run(sender = admin)
    tXRP_id = 3
    scenario.h2(&#34;set_token_active()&#34;)
    c1.set_token_active(id=tBTC_id, active=False).run(sender = creator, amount=sp.mutez(1), valid = False)
    c1.set_token_active(id=tXTZ_id, active=False).run(sender = userA, valid = False)
    c1.set_token_active(id=fake_tBTC_id, active=False).run(sender = creator, valid = False)
    c1.set_token_active(id=tXRP_id, active=True).run(sender = admin, valid = False)
    c1.set_token_active(id=tXRP_id, active=False).run(sender = admin)


    scenario.h1(&#34;Loans&#34;)
    scenario.h2(&#34;add_loan()&#34;)
    scenario.p(&#34;Loan token is not active (error):&#34;)
    c1.add_loan(loan_token_id=tXRP_id, loan_amount=10_000, reward=1000,
        deposit_token_id=tXTZ_id, deposit_amount=15_000_000, time=7*DAY, validity=sp.none
        ).run(sender=userA, amount=sp.mutez(15_000_000), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    scenario.p(&#34;Loan token is not supported (error):&#34;)
    c1.add_loan(loan_token_id=fake_tBTC_id, loan_amount=10_000, reward=1000,
        deposit_token_id=tXTZ_id, deposit_amount=15_000_000, time=7*DAY, validity=sp.none
        ).run(sender=userA, amount=sp.mutez(15_000_000), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    scenario.p(&#34;Loan amount is 0 (error):&#34;)
    c1.add_loan(loan_token_id=tETH_id, loan_amount=0, reward=1000,
        deposit_token_id=tXTZ_id, deposit_amount=15_000_000, time=7*DAY, validity=sp.none
        ).run(sender=userA, amount=sp.mutez(15_000_000), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    scenario.p(&#34;Loan_token = deposit_token (error):&#34;)
    c1.add_loan(loan_token_id=tETH_id, loan_amount=10_000, reward=1000,
        deposit_token_id=tETH_id, deposit_amount=10_000, time=7*DAY, validity=sp.none
        ).run(sender=userA, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    scenario.p(&#34;Deposit token name is not active (error):&#34;)
    c1.add_loan(loan_token_id=tETH_id, loan_amount=10_000, reward=1000,
        deposit_token_id=tXRP_id, deposit_amount=15_000_000, time=7*DAY, validity=sp.none
        ).run(sender=userA, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    scenario.p(&#34;Deposit token is not supported (error):&#34;)
    c1.add_loan(loan_token_id=tETH_id, loan_amount=10_000, reward=1000,
        deposit_token_id=fake_tBTC_id, deposit_amount=15_000_000, time=7*DAY, validity=sp.none
        ).run(sender=userA, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    scenario.p(&#34;Time is too small (error):&#34;)
    c1.add_loan(loan_token_id=tETH_id, loan_amount=10_000, reward=1000,
        deposit_token_id=tBTC_id, deposit_amount=15_000_000, time=1, validity=sp.none
        ).run(sender=userA, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    scenario.p(&#34;Time is too big (error):&#34;)
    c1.add_loan(loan_token_id=tETH_id, loan_amount=10_000, reward=1000,
        deposit_token_id=tBTC_id, deposit_amount=15_000_000, time=456*DAY, validity=sp.none
        ).run(sender=userA, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    scenario.p(&#34;Loan request is expired (error):&#34;)
    c1.add_loan(loan_token_id=tETH_id, loan_amount=10_000, reward=1000,
        deposit_token_id=tBTC_id, deposit_amount=15_000_000, time=7*DAY, validity=sp.some(sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
        ).run(sender=userA, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    scenario.p(&#34;Incorrect XTZ deposit amount (error):&#34;)
    c1.add_loan(loan_token_id=tETH_id, loan_amount=10_000, reward=1000,
        deposit_token_id=tXTZ_id, deposit_amount=15_000_000, time=7*DAY, validity=sp.none
        ).run(sender=userA, amount=sp.mutez(1_000_000), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    scenario.p(&#34;XTZ transaction amount &gt; 0 (error):&#34;)
    c1.add_loan(loan_token_id=tETH_id, loan_amount=10_000, reward=1000,
        deposit_token_id=tBTC_id, deposit_amount=15_000_000, time=7*DAY, validity=sp.none
        ).run(sender=userA, amount=sp.mutez(15_000_000), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    scenario.p(&#34;Loan request in tokens with deposit in XTZ with validity:&#34;)
    c1.add_loan(loan_token_id=tETH_id, loan_amount=10_000, reward=1000,
        deposit_token_id=tXTZ_id, deposit_amount=15_000_000, time=7*DAY, validity=sp.some(sp.timestamp_from_utc(2022, 5, 14, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(15_000_000), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    scenario.p(&#34;Loan request in tokens with deposit in XTZ without validity:&#34;)
    c1.add_loan(loan_token_id=tBTC_id, loan_amount=20_000, reward=200,
        deposit_token_id=tXTZ_id, deposit_amount=100_000_000, time=14*DAY, validity=sp.none
        ).run(sender=userB, amount=sp.mutez(100_000_000), now=sp.timestamp_from_utc(2022, 5, 2, 0, 0, 0))
    scenario.p(&#34;Loan request in tokens with deposit in tokens without validity:&#34;)
    c1.add_loan(loan_token_id=tETH_id, loan_amount=2000, reward=200,
        deposit_token_id=tBTC_id, deposit_amount=200_000, time=7*DAY, validity=sp.none
        ).run(sender=userA, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    scenario.h2(&#34;cancel_loan()&#34;)
    scenario.p(&#34;XTZ transaction amount &gt; 0 (error):&#34;)
    c1.cancel_loan(id=1).run(sender = userA, amount=sp.mutez(1), valid = False)
    scenario.p(&#34;Incorrect loan request id (error):&#34;)
    c1.cancel_loan(id=123).run(sender = userA, valid = False)
    scenario.p(&#34;Sender is not loan request creator (error):&#34;)
    c1.cancel_loan(id=1).run(sender = userB, valid = False)
    scenario.p(&#34;Cancel loan requests:&#34;)
    c1.cancel_loan(id=1).run(sender = userA)
    c1.cancel_loan(id=2).run(sender = admin)
    c1.cancel_loan(id=3).run(sender = userA)


    scenario.h1(&#34;Deals&#34;)
    scenario.p(&#34;Add loan requests:&#34;)
    c1.add_loan(loan_token_id=tBTC_id, loan_amount=1000, reward=100,
        deposit_token_id=tXTZ_id, deposit_amount=100_000, time=7*DAY, validity=sp.some(sp.timestamp_from_utc(2022, 5, 10, 0, 0, 0))
        ).run(sender=userA, amount=sp.mutez(100_000), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    c1.add_loan(loan_token_id=tETH_id, loan_amount=2000, reward=200,
        deposit_token_id=tBTC_id, deposit_amount=200_000, time=7*DAY, validity=sp.none
        ).run(sender=userA, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    c1.add_loan(loan_token_id=tXTZ_id, loan_amount=3000, reward=300,
        deposit_token_id=tETH_id, deposit_amount=300_000, time=7*DAY, validity=sp.none
        ).run(sender=userA, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    c1.add_loan(loan_token_id=tETH_id, loan_amount=2000, reward=200,
        deposit_token_id=tBTC_id, deposit_amount=200_000, time=7*DAY, validity=sp.none
        ).run(sender=userA, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    # scenario.h2(&#34;remove_token() with locked amount &gt; 0&#34;)
    # c1.remove_token(n=tXTZ.n).run(sender = creator, valid = False)
    # c1.remove_token(n=tBTC.n).run(sender = admin, valid = False)
    scenario.h2(&#34;make_deal()&#34;)
    scenario.p(&#34;Incorrect loan request id (error):&#34;)
    c1.make_deal(id=1).run(sender=userB, valid = False)
    scenario.p(&#34;Borrower can&#39;t be creditor (error):&#34;)
    c1.make_deal(id=4).run(sender=userA, valid = False)
    scenario.p(&#34;Loan request is expired (error):&#34;)
    c1.make_deal(id=4).run(sender=userB, now=sp.timestamp_from_utc(2022, 5, 10, 0, 0, 0), valid = False)
    scenario.p(&#34;Requested XTZ amount is incorrect (error):&#34;)
    c1.make_deal(id=6).run(sender=userB, amount=sp.mutez(10), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    scenario.p(&#34;XTZ amount is incorrect (error):&#34;)
    c1.make_deal(id=4).run(sender=userB, amount=sp.mutez(10), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    scenario.p(&#34;Making correct deals:&#34;)
    c1.make_deal(id=4).run(sender=userB, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    c1.make_deal(id=5).run(sender=userB, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    c1.make_deal(id=6).run(sender=userB, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), amount=sp.mutez(3000))
    c1.make_deal(id=7).run(sender=userB, now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    scenario.h2(&#34;close_deal()&#34;)
    scenario.p(&#34;Incorrect deal id (error):&#34;)
    c1.close_deal(id=0).run(sender=userA, valid = False)
    scenario.p(&#34;Incorrect user (error):&#34;)
    c1.close_deal(id=1).run(sender=userC, valid = False)
    scenario.p(&#34;Creditor can&#39;t close deal because it&#39;s not expired (error):&#34;)
    c1.close_deal(id=1).run(sender=userB, now=sp.timestamp_from_utc(2022, 5, 2, 0, 0, 0), valid = False)
    scenario.p(&#34;Borrower can&#39;t close deal because XTZ amount is incorrect (error):&#34;)
    c1.close_deal(id=3).run(sender=userA, amount=sp.mutez(3000), now=sp.timestamp_from_utc(2022, 5, 2, 0, 0, 0), valid = False)
    scenario.p(&#34;Borrower can&#39;t close deal because XTZ amount has to be 0 (error):&#34;)
    c1.close_deal(id=1).run(sender=userA, amount=sp.mutez(1), now=sp.timestamp_from_utc(2022, 5, 2, 0, 0, 0), valid = False)
    scenario.p(&#34;Close deals:&#34;)
    scenario.p(&#34;Borrower returns tokens:&#34;)
    c1.close_deal(id=1).run(sender=userA, now=sp.timestamp_from_utc(2022, 5, 2, 0, 0, 0))
    scenario.p(&#34;Borrower returns XTZ:&#34;)
    c1.close_deal(id=3).run(sender=userA, amount=sp.mutez(3300), now=sp.timestamp_from_utc(2022, 5, 2, 0, 0, 0))
    scenario.p(&#34;Creditor closes deal:&#34;)
    c1.close_deal(id=2).run(sender=userB, now=sp.timestamp_from_utc(2022, 5, 12, 0, 0, 0))
    scenario.p(&#34;Admin closes deal:&#34;)
    c1.close_deal(id=4).run(sender=admin, now=sp.timestamp_from_utc(2022, 5, 12, 0, 0, 0))


    scenario.h1(&#34;Pause&#34;)
    scenario.h2(&#34;pause()&#34;)
    c1.pause(pause=True).run(sender = admin, amount=sp.mutez(1), valid = False)
    c1.pause(pause=False).run(sender = userA, valid = False)
    c1.pause(pause=False).run(sender = admin, valid = False)
    c1.pause(pause=True).run(sender = admin)
    scenario.p(&#34;Creating new loan request is not possible (error):&#34;)
    c1.add_loan(loan_token_id=tETH_id, loan_amount=1000, reward=100,
        deposit_token_id=tXTZ_id, deposit_amount=15000, time=7*DAY, validity=sp.none
        ).run(sender=userA, amount=sp.mutez(15000), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0), valid = False)
    scenario.p(&#34;Making deal is not possible (error):&#34;)
    c1.make_deal(id=1).run(sender=userC, valid = False)
    c1.pause(pause=False).run(sender = admin)


    scenario.h1(&#34;Withdraw&#34;)
    c1.add_loan(loan_token_id=tBTC_id, loan_amount=1000, reward=100,
        deposit_token_id=tXTZ_id, deposit_amount=10_000_000, time=7*DAY, validity=sp.none
        ).run(sender=userA, amount=sp.mutez(10_000_000), now=sp.timestamp_from_utc(2022, 5, 1, 0, 0, 0))
    scenario.h2(&#34;withdraw()&#34;)
    scenario.p(&#34;Sender is not admin (error):&#34;)
    c1.withdraw(to=userA.address, id=tXTZ_id, amount=1).run(sender = userA, valid = False)
    scenario.p(&#34;Token name is not XTZ (error):&#34;)
    c1.withdraw(to=admin.address, id=tBTC_id, amount=1).run(sender = admin, valid = False)
    scenario.p(&#34;Amount is 0 (error):&#34;)
    c1.withdraw(to=admin.address, id=tXTZ_id, amount=0).run(sender = admin, valid = False)
    scenario.p(&#34;Amount is too big (error):&#34;)
    c1.withdraw(to=admin.address, id=tXTZ_id, amount=sp.utils.mutez_to_nat(c1.balance)+1).run(sender = admin, valid = False)
    scenario.p(&#34;Successful withdrawal:&#34;)
    c1.withdraw(to=admin.address, id=tXTZ_id, amount=INITIAL_BALANCE).run(sender = creator)
    scenario.p(&#34;Amount is too big (error):&#34;)
    c1.withdraw(to=admin.address, id=tXTZ_id, amount=1).run(sender = creator, valid = False)
    scenario.verify(c1.balance == sp.utils.nat_to_mutez(c1.data.tokens[tXTZ_id].locked_amount))



sp.add_compilation_target(&#34;lendtez&#34;, LendTez(CREATOR_ADDRESS))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="contract.transfer_tokens"><code class="name flex">
<span>def <span class="ident">transfer_tokens</span></span>(<span>sender, receiver, amount, token)</span>
</code></dt>
<dd>
<div class="desc"><p>Help function to transfer tokens.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sender</code></strong> :&ensp;<code>address</code></dt>
<dd>source address</dd>
<dt><strong><code>receiver</code></strong> :&ensp;<code>address</code></dt>
<dd>destination address</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>nat</code></dt>
<dd>amount of tokens</dd>
<dt><strong><code>token_id</code></strong> :&ensp;<code>nat</code></dt>
<dd>deposit token ID</dd>
<dt><strong><code>token</code></strong> :&ensp;<code>TToken</code></dt>
<dd>token information</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transfer_tokens(sender, receiver, amount, token):
    &#34;&#34;&#34;Help function to transfer tokens.

    Args:
        sender (address): source address
        receiver (address): destination address
        amount (nat): amount of tokens
        token_id (nat): deposit token ID
        token (TToken): token information
    &#34;&#34;&#34;
    with sp.if_((token.type == TokenType.FA12)):
        param_values = sp.record(from_ = sender, to_ = receiver, value = amount)
        param_type = sp.TRecord(from_ = sp.TAddress, to_ = sp.TAddress, value = sp.TNat).layout((&#34;from_ as from&#34;, (&#34;to_ as to&#34;, &#34;value&#34;)))
        sp.transfer(param_values, sp.mutez(0), sp.contract(param_type, token.address, entry_point=&#34;transfer&#34;).open_some())
    with sp.else_():
        param_values = [sp.record(from_ = sender, txs = [sp.record(to_ = receiver, token_id = token.token_id, amount = amount)])]
        param_type = sp.TList(sp.TRecord(from_ = sp.TAddress, txs = sp.TList(sp.TRecord(amount = sp.TNat, to_ = sp.TAddress, token_id = sp.TNat).layout((&#34;to_&#34;, (&#34;token_id&#34;, &#34;amount&#34;))))))
        sp.transfer(param_values, sp.mutez(0), sp.contract(param_type, token.address, entry_point=&#39;transfer&#39;).open_some())</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="contract.Error"><code class="flex name class">
<span>class <span class="ident">Error</span></span>
</code></dt>
<dd>
<div class="desc"><p>The enum used for the contract related errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Error:
    &#34;&#34;&#34;The enum used for the contract related errors.&#34;&#34;&#34;

    ACCESS_DENIED = &#34;ERR_ACCESS_DENIED&#34;
    &#34;&#34;&#34;The contract function is not accessible for the sender.&#34;&#34;&#34;

    ILLEGAL_ARGUMENT = &#34;ERR_ILLEGAL_ARGUMENT&#34;
    &#34;&#34;&#34;The corresponding argument value is invalid.&#34;&#34;&#34;

    ILLEGAL_TX_AMOUNT = &#34;ERR_ILLEGAL_TX_AMOUNT&#34;
    &#34;&#34;&#34;The corresponding transaction has incorrect tezos amount.&#34;&#34;&#34;

    PAUSED = &#34;ERR_PAUSED&#34;
    &#34;&#34;&#34;The contract is paused.&#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="contract.Error.ACCESS_DENIED"><code class="name">var <span class="ident">ACCESS_DENIED</span></code></dt>
<dd>
<div class="desc"><p>The contract function is not accessible for the sender.</p></div>
</dd>
<dt id="contract.Error.ILLEGAL_ARGUMENT"><code class="name">var <span class="ident">ILLEGAL_ARGUMENT</span></code></dt>
<dd>
<div class="desc"><p>The corresponding argument value is invalid.</p></div>
</dd>
<dt id="contract.Error.ILLEGAL_TX_AMOUNT"><code class="name">var <span class="ident">ILLEGAL_TX_AMOUNT</span></code></dt>
<dd>
<div class="desc"><p>The corresponding transaction has incorrect tezos amount.</p></div>
</dd>
<dt id="contract.Error.PAUSED"><code class="name">var <span class="ident">PAUSED</span></code></dt>
<dd>
<div class="desc"><p>The contract is paused.</p></div>
</dd>
</dl>
</dd>
<dt id="contract.TokenType"><code class="flex name class">
<span>class <span class="ident">TokenType</span></span>
</code></dt>
<dd>
<div class="desc"><p>The enum used for the contract token types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TokenType:
    &#34;&#34;&#34;The enum used for the contract token types.&#34;&#34;&#34;

    XTZ  = sp.nat(0)
    &#34;&#34;&#34;Native Tezos token.&#34;&#34;&#34;

    FA12 = sp.nat(1)
    &#34;&#34;&#34;Fungible Asset (FA1.2).&#34;&#34;&#34;

    FA20 = sp.nat(2)
    &#34;&#34;&#34;Multi-Asset (FA2).&#34;&#34;&#34;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="contract.TokenType.XTZ"><code class="name">var <span class="ident">XTZ</span></code></dt>
<dd>
<div class="desc"><p>Native Tezos token.</p></div>
</dd>
<dt id="contract.TokenType.FA12"><code class="name">var <span class="ident">FA12</span></code></dt>
<dd>
<div class="desc"><p>Fungible Asset (FA1.2).</p></div>
</dd>
<dt id="contract.TokenType.FA20"><code class="name">var <span class="ident">FA20</span></code></dt>
<dd>
<div class="desc"><p>Multi-Asset (FA2).</p></div>
</dd>
</dl>
</dd>
<dt id="contract.LendTez"><code class="flex name class">
<span>class <span class="ident">LendTez</span></span>
<span>(</span><span>creator)</span>
</code></dt>
<dd>
<div class="desc"><p>The contract is a storage for p2p credit deals and provides service functionality to make such deals.</p>
<p>There is the storage:</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pause</code></strong> :&ensp;<code>bool</code></dt>
<dd>indicates that creating loan requests and making credit deals is disabled</dd>
<dt><strong><code>baker</code></strong> :&ensp;<code>option</code></dt>
<dd>baker address or <em>None</em></dd>
<dt><strong><code>admins</code></strong> :&ensp;<code>set</code></dt>
<dd>list of admin addresses</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>pair</code></dt>
<dd>time bounds for credit deals</dd>
<dt><strong><code>ntoken</code></strong> :&ensp;<code>nat</code></dt>
<dd>last token ID</dd>
<dt><strong><code>tokens</code></strong> :&ensp;<code>big_map</code></dt>
<dd>supported tokens (key is token ID)</dd>
<dt><strong><code>nloan</code></strong> :&ensp;<code>nat</code></dt>
<dd>last loan request ID</dd>
<dt><strong><code>loans</code></strong> :&ensp;<code>big_map</code></dt>
<dd>map of loan requests (key is loan request ID)</dd>
<dt><strong><code>ndeal</code></strong> :&ensp;<code>nat</code></dt>
<dd>last credit deal ID</dd>
<dt><strong><code>deals</code></strong> :&ensp;<code>big_map</code></dt>
<dd>map of credit deals (key is credit deal ID)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LendTez(sp.Contract):
    &#34;&#34;&#34;The contract is a storage for p2p credit deals and provides service functionality to make such deals.

    There is the storage:
    Args:
        pause (bool): indicates that creating loan requests and making credit deals is disabled
        baker (option): baker address or _None_
        admins (set): list of admin addresses
        time (pair): time bounds for credit deals
        ntoken (nat): last token ID
        tokens (big_map): supported tokens (key is token ID)
        nloan (nat): last loan request ID
        loans (big_map): map of loan requests (key is loan request ID)
        ndeal (nat): last credit deal ID
        deals (big_map): map of credit deals (key is credit deal ID)
    &#34;&#34;&#34;

    def __init__(self, creator):
        self.creator = creator

        self.init(
            pause = False,
            baker = sp.none,
            admins = sp.set([creator]),
            time = sp.record(min = sp.nat(7 * 86400), max = sp.nat(180 * 86400)),
            ntoken = sp.nat(0),
            tokens = sp.big_map(),
            nloan = sp.nat(0),
            loans = sp.big_map(),
            ndeal = sp.nat(0),
            deals = sp.big_map(),
        )


    @sp.entry_point
    def default(self):
        &#34;&#34;&#34;Support tezos transfer to the contract address.&#34;&#34;&#34;
        pass


    @sp.entry_point
    def withdraw(self, params):
        &#34;&#34;&#34;(Admins only) Transfer XTZ (except locked collateral) from the contract address.
        
        Args:
            to (address): destination address
            id (nat): token ID of XTZ
            amount (mutez): XTZ amount
        Raises:
            `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.to, sp.TAddress)
        sp.set_type(params.id, sp.TNat)
        sp.set_type(params.amount, sp.TNat)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.tokens.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        sp.verify(self.data.tokens[params.id].type == TokenType.XTZ, message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        sp.verify(params.amount &gt; 0, message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
        sp.verify(sp.utils.mutez_to_nat(sp.balance) &gt;= (self.data.tokens[params.id].locked_amount + params.amount), message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
        sp.send(params.to, sp.utils.nat_to_mutez(params.amount))


    @sp.entry_point
    def add_admin(self, params):
        &#34;&#34;&#34;(Admins only) Add an admin address to the list of admin addresses.
        
        Args:
            address (address): new admin address
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.address, sp.TAddress)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(~self.data.admins.contains(params.address), message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
        self.data.admins.add(params.address)


    @sp.entry_point
    def remove_admin(self, params):
        &#34;&#34;&#34;(Admins only) Remove an admin address from the list of admin addresses.

        Args:
            address (address): admin address
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.address, sp.TAddress)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.creator != params.address, message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
        sp.verify(self.data.admins.contains(params.address), message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
        self.data.admins.remove(params.address)


    @sp.entry_point
    def delegate(self, params):
        &#34;&#34;&#34;(Admins only) Set a baker for the contract.

        Args:
            baker (option): baker address or _None_
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.baker, sp.TOption(sp.TKeyHash))
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.baker != params.baker, message = Error.ILLEGAL_ARGUMENT + &#34;:baker&#34;)
        self.data.baker = params.baker
        sp.set_delegate(params.baker)


    @sp.entry_point
    def pause(self, params):
        &#34;&#34;&#34;(Admins only) Disable/enable making of new loan requests and new deals.

        Args:
            pause (bool): _True_ or _False_
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.pause, sp.TBool)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.pause != params.pause, message = Error.ILLEGAL_ARGUMENT + &#34;:pause&#34;)
        self.data.pause = params.pause


    @sp.entry_point
    def set_time(self, params):
        &#34;&#34;&#34;(Admins only) Set time bounds for credit deals.

        Args:
            min (nat): minimum deal duration in seconds
            max (nat): maximum deal duration in seconds
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params, sp.TRecord(min = sp.TNat, max = sp.TNat))
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.time != params, message = Error.ILLEGAL_ARGUMENT + &#34;:min,max&#34;)
        sp.verify((params.min &gt; 0) &amp; (params.min &lt;= params.max), message = Error.ILLEGAL_ARGUMENT + &#34;:min&#34;)
        self.data.time = params


    @sp.entry_point
    def add_token(self, params):
        &#34;&#34;&#34;(Admins only) Add supported token.

        Args:
            name (string): token name
            address (address): token address
            type (nat): token type (TokenType.XTZ or TokenType.FA12 or TokenType.FA20)
            token_id (nat): token id for the corresponding token address
            decimals (nat): decimals
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params, TToken)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify((params.type == TokenType.XTZ) | (params.type == TokenType.FA12) | (params.type == TokenType.FA20), message = Error.ILLEGAL_ARGUMENT + &#34;:type&#34;)
        self.data.tokens[self.data.ntoken] = sp.record(
            name = params.name,
            address = params.address,
            type = params.type,
            token_id = params.token_id,
            decimals = params.decimals,
            locked_amount = 0,
            active = True
        )
        self.data.ntoken += 1


    @sp.entry_point
    def set_token_active(self, params):
        &#34;&#34;&#34;(Admins only) Set active status for supported token.

        Args:
            id (nat): token id
            active (bool): active status (a token can not be a part of a loan request if active=_False_)
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.id, sp.TNat)
        sp.set_type(params.active, sp.TBool)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
        sp.verify(self.data.tokens.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        sp.verify(self.data.tokens[params.id].active != params.active, message = Error.ILLEGAL_ARGUMENT + &#34;:active&#34;)
        self.data.tokens[params.id].active = params.active


    @sp.entry_point
    def add_loan(self, params):
        &#34;&#34;&#34;Create a new loan request.
        
        The corresponding transaction amount has to include deposit, if the deposit is XTZ.

        Args:
            loan_token_id (nat): loan token ID
            loan_amount (nat): requested amount of tokens
            reward (nat): amount of tokens as creditor&#39;s reward 
            deposit_token_id (nat): deposit token ID
            deposit_amount (nat): deposit amount of tokens
            time (nat): credit deal duration in seconds
            validity (option): loan request expire date or None
        Raises:
            `OD_PAUSED`, `OD_ILLEGAL_TX_AMOUNT`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.loan_token_id, sp.TNat)
        sp.set_type(params.loan_amount, sp.TNat)
        sp.set_type(params.reward, sp.TNat)
        sp.set_type(params.deposit_token_id, sp.TNat)
        sp.set_type(params.deposit_amount, sp.TNat)
        sp.set_type(params.time, sp.TNat)
        sp.set_type(params.validity, sp.TOption(sp.TTimestamp))
        sp.verify(~self.data.pause, message = Error.PAUSED)
        sp.verify(self.data.tokens.contains(params.loan_token_id), message = Error.ILLEGAL_ARGUMENT + &#34;:loan_token_id&#34;)
        sp.verify(self.data.tokens[params.loan_token_id].active, message = Error.ILLEGAL_ARGUMENT + &#34;:loan_token&#34;)
        sp.verify(params.loan_amount &gt; 0, message = Error.ILLEGAL_ARGUMENT + &#34;:loan_amount&#34;)
        sp.verify(params.loan_token_id != params.deposit_token_id , message = Error.ILLEGAL_ARGUMENT + &#34;:deposit_token&#34;)
        sp.verify(self.data.tokens.contains(params.deposit_token_id), message = Error.ILLEGAL_ARGUMENT + &#34;:deposit_token_id&#34;)
        sp.verify(self.data.tokens[params.deposit_token_id].active, message = Error.ILLEGAL_ARGUMENT + &#34;:deposit_token&#34;)
        sp.verify((params.time &gt;= self.data.time.min) &amp; (params.time &lt;= self.data.time.max), message = Error.ILLEGAL_ARGUMENT + &#34;:time&#34;)
        sp.verify((params.validity == sp.none) | (params.validity &gt; sp.some(sp.now)), message = Error.ILLEGAL_ARGUMENT + &#34;:validity&#34;)

        deposit_token = sp.local(&#34;deposit_token&#34;, self.data.tokens[params.deposit_token_id])
        with sp.if_((deposit_token.value.type == TokenType.XTZ)):
            sp.verify(params.deposit_amount == sp.utils.mutez_to_nat(sp.amount), message = Error.ILLEGAL_TX_AMOUNT)
        with sp.else_():
            sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
            with sp.if_((params.deposit_amount &gt; 0)):
                transfer_tokens(sender = sp.sender, receiver = sp.self_address, amount = params.deposit_amount, token = deposit_token.value)
        self.data.tokens[params.deposit_token_id].locked_amount += params.deposit_amount
        self.data.nloan += 1
        self.data.loans[self.data.nloan] = sp.record(
            ts = sp.now,
            borrower = sp.sender,
            loan_token_id = params.loan_token_id,
            loan_amount = params.loan_amount,
            reward = params.reward,
            deposit_token_id = params.deposit_token_id,
            deposit_amount = params.deposit_amount,
            time = params.time,
            validity = params.validity
        )


    @sp.entry_point
    def cancel_loan(self, params):
        &#34;&#34;&#34;Cancel sender&#39;s loan request, the deposit of the loan is returned to the sender.

        Args:
            id (nat): loan request ID
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.id, sp.TNat)
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        sp.verify(self.data.loans.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        loan = sp.local(&#34;loan&#34;, self.data.loans[params.id])
        sp.verify((sp.sender == loan.value.borrower) | self.data.admins.contains(sp.sender), Error.ACCESS_DENIED)
        self.refund_deposit(receiver = loan.value.borrower, token_id = loan.value.deposit_token_id, amount = loan.value.deposit_amount)
        del self.data.loans[params.id]


    @sp.entry_point
    def make_deal(self, params):
        &#34;&#34;&#34;Make a credit deal, the sender has to approve the corresponding token transfer early.

        Args:
            id (nat): loan request ID
        Raises:
            `OD_PAUSED`, `OD_ILLEGAL_TX_AMOUNT`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.id, sp.TNat)
        sp.verify(~self.data.pause, message = Error.PAUSED)
        sp.verify(self.data.loans.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        loan = sp.local(&#34;loan&#34;, self.data.loans[params.id])
        sp.verify(loan.value.borrower != sp.sender, Error.ILLEGAL_ARGUMENT + &#34;:sender&#34;)
        sp.verify((loan.value.validity == sp.none) | (loan.value.validity &gt; sp.some(sp.now)), message = Error.ILLEGAL_ARGUMENT + &#34;:now&#34;)
        loan_token = sp.local(&#34;loan_token&#34;, self.data.tokens[loan.value.loan_token_id])
        with sp.if_((loan_token.value.type == TokenType.XTZ)):
            sp.verify(loan.value.loan_amount == sp.utils.mutez_to_nat(sp.amount), message = Error.ILLEGAL_TX_AMOUNT)
            sp.send(loan.value.borrower, sp.amount)
        with sp.else_():
            sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
            transfer_tokens(sender = sp.sender, receiver = loan.value.borrower, amount = loan.value.loan_amount, token = loan_token.value)
        self.data.ndeal += 1
        self.data.deals[self.data.ndeal] = sp.record(
            ts = sp.now,
            borrower = loan.value.borrower,
            creditor = sp.sender,
            loan_token_id = loan.value.loan_token_id,
            loan_amount = loan.value.loan_amount,
            reward = loan.value.reward,
            exp = sp.now.add_seconds(sp.to_int(loan.value.time)),
            deposit_token_id = loan.value.deposit_token_id,
            deposit_amount = loan.value.deposit_amount,
        )
        del self.data.loans[params.id]


    @sp.entry_point
    def close_deal(self, params):
        &#34;&#34;&#34;Close a deal by borrower or creditor/admins.

        If a deal is closed by borrower, the tokens are sent to the creditor and the borrower gets back the deposit;
        if a deal timed out and it&#39;s closed by the creditor or admins, the creditor gets the deposit.

        Args:
            id (nat): credit deal ID
        Raises:
            `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
        &#34;&#34;&#34;
        sp.set_type(params.id, sp.TNat)
        sp.verify(self.data.deals.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
        deal = sp.local(&#34;deal&#34;, self.data.deals[params.id])
        sp.verify((sp.sender == deal.value.borrower) | (sp.sender == deal.value.creditor) | self.data.admins.contains(sp.sender), Error.ACCESS_DENIED)
        deposit_receiver = sp.local(&#39;deposit_receiver&#39;, sp.self_address)
        with sp.if_(sp.sender == deal.value.borrower):
            loan_token = sp.local(&#34;loan_token&#34;, self.data.tokens[deal.value.loan_token_id])
            with sp.if_((loan_token.value.type == TokenType.XTZ)):
                sp.verify((deal.value.loan_amount + deal.value.reward) == sp.utils.mutez_to_nat(sp.amount), message = Error.ILLEGAL_TX_AMOUNT)
                sp.send(deal.value.creditor, sp.amount)
            with sp.else_():
                sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
                transfer_tokens(sender = deal.value.borrower, receiver = deal.value.creditor, amount = (deal.value.loan_amount + deal.value.reward), token = loan_token.value)
            deposit_receiver.value = deal.value.borrower
        with sp.else_():
            sp.verify(deal.value.exp &lt; sp.now, message = Error.ACCESS_DENIED)
            deposit_receiver.value = deal.value.creditor
        self.refund_deposit(receiver = deposit_receiver.value, token_id = deal.value.deposit_token_id, amount = deal.value.deposit_amount)
        del self.data.deals[params.id]


    def refund_deposit(self, receiver, token_id, amount):
        &#34;&#34;&#34;Help function to send deposit.

        Args:
            receiver (address): destination address
            token_id (nat): deposit token ID
            amount (nat): deposit amount of tokens
        &#34;&#34;&#34;
        with sp.if_(amount &gt; 0):
            deposit_token = sp.local(&#34;deposit_token&#34;, self.data.tokens[token_id])
            with sp.if_((deposit_token.value.type == TokenType.XTZ)):
                sp.send(receiver, sp.utils.nat_to_mutez(amount))
            with sp.else_():
                transfer_tokens(sender = sp.self_address, receiver = receiver, amount = amount, token = deposit_token.value)
            self.data.tokens[token_id].locked_amount = sp.as_nat(self.data.tokens[token_id].locked_amount - amount)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>smartpy.Contract</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="contract.LendTez.default"><code class="name flex">
<span>def <span class="ident">default</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. Support tezos transfer to the contract address.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def default(self):
    &#34;&#34;&#34;Support tezos transfer to the contract address.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="contract.LendTez.withdraw"><code class="name flex">
<span>def <span class="ident">withdraw</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Transfer XTZ (except locked collateral) from the contract address.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>to</code></strong> :&ensp;<code>address</code></dt>
<dd>destination address</dd>
<dt><strong><code>id</code></strong> :&ensp;<code>nat</code></dt>
<dd>token ID of XTZ</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>mutez</code></dt>
<dd>XTZ amount</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def withdraw(self, params):
    &#34;&#34;&#34;(Admins only) Transfer XTZ (except locked collateral) from the contract address.
    
    Args:
        to (address): destination address
        id (nat): token ID of XTZ
        amount (mutez): XTZ amount
    Raises:
        `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.to, sp.TAddress)
    sp.set_type(params.id, sp.TNat)
    sp.set_type(params.amount, sp.TNat)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(self.data.tokens.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
    sp.verify(self.data.tokens[params.id].type == TokenType.XTZ, message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
    sp.verify(params.amount &gt; 0, message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
    sp.verify(sp.utils.mutez_to_nat(sp.balance) &gt;= (self.data.tokens[params.id].locked_amount + params.amount), message = Error.ILLEGAL_ARGUMENT + &#34;:amount&#34;)
    sp.send(params.to, sp.utils.nat_to_mutez(params.amount))</code></pre>
</details>
</dd>
<dt id="contract.LendTez.add_admin"><code class="name flex">
<span>def <span class="ident">add_admin</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Add an admin address to the list of admin addresses.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>address</code></dt>
<dd>new admin address</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def add_admin(self, params):
    &#34;&#34;&#34;(Admins only) Add an admin address to the list of admin addresses.
    
    Args:
        address (address): new admin address
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.address, sp.TAddress)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(~self.data.admins.contains(params.address), message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
    self.data.admins.add(params.address)</code></pre>
</details>
</dd>
<dt id="contract.LendTez.remove_admin"><code class="name flex">
<span>def <span class="ident">remove_admin</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Remove an admin address from the list of admin addresses.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>address</code></strong> :&ensp;<code>address</code></dt>
<dd>admin address</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def remove_admin(self, params):
    &#34;&#34;&#34;(Admins only) Remove an admin address from the list of admin addresses.

    Args:
        address (address): admin address
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.address, sp.TAddress)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(self.creator != params.address, message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
    sp.verify(self.data.admins.contains(params.address), message = Error.ILLEGAL_ARGUMENT + &#34;:address&#34;)
    self.data.admins.remove(params.address)</code></pre>
</details>
</dd>
<dt id="contract.LendTez.delegate"><code class="name flex">
<span>def <span class="ident">delegate</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Set a baker for the contract.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>baker</code></strong> :&ensp;<code>option</code></dt>
<dd>baker address or <em>None</em></dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def delegate(self, params):
    &#34;&#34;&#34;(Admins only) Set a baker for the contract.

    Args:
        baker (option): baker address or _None_
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.baker, sp.TOption(sp.TKeyHash))
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(self.data.baker != params.baker, message = Error.ILLEGAL_ARGUMENT + &#34;:baker&#34;)
    self.data.baker = params.baker
    sp.set_delegate(params.baker)</code></pre>
</details>
</dd>
<dt id="contract.LendTez.pause"><code class="name flex">
<span>def <span class="ident">pause</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Disable/enable making of new loan requests and new deals.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pause</code></strong> :&ensp;<code>bool</code></dt>
<dd><em>True</em> or <em>False</em></dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def pause(self, params):
    &#34;&#34;&#34;(Admins only) Disable/enable making of new loan requests and new deals.

    Args:
        pause (bool): _True_ or _False_
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.pause, sp.TBool)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(self.data.pause != params.pause, message = Error.ILLEGAL_ARGUMENT + &#34;:pause&#34;)
    self.data.pause = params.pause</code></pre>
</details>
</dd>
<dt id="contract.LendTez.set_time"><code class="name flex">
<span>def <span class="ident">set_time</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Set time bounds for credit deals.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>min</code></strong> :&ensp;<code>nat</code></dt>
<dd>minimum deal duration in seconds</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>nat</code></dt>
<dd>maximum deal duration in seconds</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def set_time(self, params):
    &#34;&#34;&#34;(Admins only) Set time bounds for credit deals.

    Args:
        min (nat): minimum deal duration in seconds
        max (nat): maximum deal duration in seconds
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params, sp.TRecord(min = sp.TNat, max = sp.TNat))
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(self.data.time != params, message = Error.ILLEGAL_ARGUMENT + &#34;:min,max&#34;)
    sp.verify((params.min &gt; 0) &amp; (params.min &lt;= params.max), message = Error.ILLEGAL_ARGUMENT + &#34;:min&#34;)
    self.data.time = params</code></pre>
</details>
</dd>
<dt id="contract.LendTez.add_token"><code class="name flex">
<span>def <span class="ident">add_token</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Add supported token.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>string</code></dt>
<dd>token name</dd>
<dt><strong><code>address</code></strong> :&ensp;<code>address</code></dt>
<dd>token address</dd>
<dt><strong><code>type</code></strong> :&ensp;<code>nat</code></dt>
<dd>token type (TokenType.XTZ or TokenType.FA12 or TokenType.FA20)</dd>
<dt><strong><code>token_id</code></strong> :&ensp;<code>nat</code></dt>
<dd>token id for the corresponding token address</dd>
<dt><strong><code>decimals</code></strong> :&ensp;<code>nat</code></dt>
<dd>decimals</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def add_token(self, params):
    &#34;&#34;&#34;(Admins only) Add supported token.

    Args:
        name (string): token name
        address (address): token address
        type (nat): token type (TokenType.XTZ or TokenType.FA12 or TokenType.FA20)
        token_id (nat): token id for the corresponding token address
        decimals (nat): decimals
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params, TToken)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify((params.type == TokenType.XTZ) | (params.type == TokenType.FA12) | (params.type == TokenType.FA20), message = Error.ILLEGAL_ARGUMENT + &#34;:type&#34;)
    self.data.tokens[self.data.ntoken] = sp.record(
        name = params.name,
        address = params.address,
        type = params.type,
        token_id = params.token_id,
        decimals = params.decimals,
        locked_amount = 0,
        active = True
    )
    self.data.ntoken += 1</code></pre>
</details>
</dd>
<dt id="contract.LendTez.set_token_active"><code class="name flex">
<span>def <span class="ident">set_token_active</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. (Admins only) Set active status for supported token.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>nat</code></dt>
<dd>token id</dd>
<dt><strong><code>active</code></strong> :&ensp;<code>bool</code></dt>
<dd>active status (a token can not be a part of a loan request if active=<em>False</em>)</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def set_token_active(self, params):
    &#34;&#34;&#34;(Admins only) Set active status for supported token.

    Args:
        id (nat): token id
        active (bool): active status (a token can not be a part of a loan request if active=_False_)
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.id, sp.TNat)
    sp.set_type(params.active, sp.TBool)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.admins.contains(sp.sender), message = Error.ACCESS_DENIED)
    sp.verify(self.data.tokens.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
    sp.verify(self.data.tokens[params.id].active != params.active, message = Error.ILLEGAL_ARGUMENT + &#34;:active&#34;)
    self.data.tokens[params.id].active = params.active</code></pre>
</details>
</dd>
<dt id="contract.LendTez.add_loan"><code class="name flex">
<span>def <span class="ident">add_loan</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. Create a new loan request.</p>
<p>The corresponding transaction amount has to include deposit, if the deposit is XTZ.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>loan_token_id</code></strong> :&ensp;<code>nat</code></dt>
<dd>loan token ID</dd>
<dt><strong><code>loan_amount</code></strong> :&ensp;<code>nat</code></dt>
<dd>requested amount of tokens</dd>
<dt><strong><code>reward</code></strong> :&ensp;<code>nat</code></dt>
<dd>amount of tokens as creditor's reward </dd>
<dt><strong><code>deposit_token_id</code></strong> :&ensp;<code>nat</code></dt>
<dd>deposit token ID</dd>
<dt><strong><code>deposit_amount</code></strong> :&ensp;<code>nat</code></dt>
<dd>deposit amount of tokens</dd>
<dt><strong><code>time</code></strong> :&ensp;<code>nat</code></dt>
<dd>credit deal duration in seconds</dd>
<dt><strong><code>validity</code></strong> :&ensp;<code>option</code></dt>
<dd>loan request expire date or None</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_PAUSED</code>, <code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def add_loan(self, params):
    &#34;&#34;&#34;Create a new loan request.
    
    The corresponding transaction amount has to include deposit, if the deposit is XTZ.

    Args:
        loan_token_id (nat): loan token ID
        loan_amount (nat): requested amount of tokens
        reward (nat): amount of tokens as creditor&#39;s reward 
        deposit_token_id (nat): deposit token ID
        deposit_amount (nat): deposit amount of tokens
        time (nat): credit deal duration in seconds
        validity (option): loan request expire date or None
    Raises:
        `OD_PAUSED`, `OD_ILLEGAL_TX_AMOUNT`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.loan_token_id, sp.TNat)
    sp.set_type(params.loan_amount, sp.TNat)
    sp.set_type(params.reward, sp.TNat)
    sp.set_type(params.deposit_token_id, sp.TNat)
    sp.set_type(params.deposit_amount, sp.TNat)
    sp.set_type(params.time, sp.TNat)
    sp.set_type(params.validity, sp.TOption(sp.TTimestamp))
    sp.verify(~self.data.pause, message = Error.PAUSED)
    sp.verify(self.data.tokens.contains(params.loan_token_id), message = Error.ILLEGAL_ARGUMENT + &#34;:loan_token_id&#34;)
    sp.verify(self.data.tokens[params.loan_token_id].active, message = Error.ILLEGAL_ARGUMENT + &#34;:loan_token&#34;)
    sp.verify(params.loan_amount &gt; 0, message = Error.ILLEGAL_ARGUMENT + &#34;:loan_amount&#34;)
    sp.verify(params.loan_token_id != params.deposit_token_id , message = Error.ILLEGAL_ARGUMENT + &#34;:deposit_token&#34;)
    sp.verify(self.data.tokens.contains(params.deposit_token_id), message = Error.ILLEGAL_ARGUMENT + &#34;:deposit_token_id&#34;)
    sp.verify(self.data.tokens[params.deposit_token_id].active, message = Error.ILLEGAL_ARGUMENT + &#34;:deposit_token&#34;)
    sp.verify((params.time &gt;= self.data.time.min) &amp; (params.time &lt;= self.data.time.max), message = Error.ILLEGAL_ARGUMENT + &#34;:time&#34;)
    sp.verify((params.validity == sp.none) | (params.validity &gt; sp.some(sp.now)), message = Error.ILLEGAL_ARGUMENT + &#34;:validity&#34;)

    deposit_token = sp.local(&#34;deposit_token&#34;, self.data.tokens[params.deposit_token_id])
    with sp.if_((deposit_token.value.type == TokenType.XTZ)):
        sp.verify(params.deposit_amount == sp.utils.mutez_to_nat(sp.amount), message = Error.ILLEGAL_TX_AMOUNT)
    with sp.else_():
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        with sp.if_((params.deposit_amount &gt; 0)):
            transfer_tokens(sender = sp.sender, receiver = sp.self_address, amount = params.deposit_amount, token = deposit_token.value)
    self.data.tokens[params.deposit_token_id].locked_amount += params.deposit_amount
    self.data.nloan += 1
    self.data.loans[self.data.nloan] = sp.record(
        ts = sp.now,
        borrower = sp.sender,
        loan_token_id = params.loan_token_id,
        loan_amount = params.loan_amount,
        reward = params.reward,
        deposit_token_id = params.deposit_token_id,
        deposit_amount = params.deposit_amount,
        time = params.time,
        validity = params.validity
    )</code></pre>
</details>
</dd>
<dt id="contract.LendTez.cancel_loan"><code class="name flex">
<span>def <span class="ident">cancel_loan</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. Cancel sender's loan request, the deposit of the loan is returned to the sender.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>nat</code></dt>
<dd>loan request ID</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def cancel_loan(self, params):
    &#34;&#34;&#34;Cancel sender&#39;s loan request, the deposit of the loan is returned to the sender.

    Args:
        id (nat): loan request ID
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.id, sp.TNat)
    sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
    sp.verify(self.data.loans.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
    loan = sp.local(&#34;loan&#34;, self.data.loans[params.id])
    sp.verify((sp.sender == loan.value.borrower) | self.data.admins.contains(sp.sender), Error.ACCESS_DENIED)
    self.refund_deposit(receiver = loan.value.borrower, token_id = loan.value.deposit_token_id, amount = loan.value.deposit_amount)
    del self.data.loans[params.id]</code></pre>
</details>
</dd>
<dt id="contract.LendTez.make_deal"><code class="name flex">
<span>def <span class="ident">make_deal</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. Make a credit deal, the sender has to approve the corresponding token transfer early.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>nat</code></dt>
<dd>loan request ID</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_PAUSED</code>, <code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def make_deal(self, params):
    &#34;&#34;&#34;Make a credit deal, the sender has to approve the corresponding token transfer early.

    Args:
        id (nat): loan request ID
    Raises:
        `OD_PAUSED`, `OD_ILLEGAL_TX_AMOUNT`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.id, sp.TNat)
    sp.verify(~self.data.pause, message = Error.PAUSED)
    sp.verify(self.data.loans.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
    loan = sp.local(&#34;loan&#34;, self.data.loans[params.id])
    sp.verify(loan.value.borrower != sp.sender, Error.ILLEGAL_ARGUMENT + &#34;:sender&#34;)
    sp.verify((loan.value.validity == sp.none) | (loan.value.validity &gt; sp.some(sp.now)), message = Error.ILLEGAL_ARGUMENT + &#34;:now&#34;)
    loan_token = sp.local(&#34;loan_token&#34;, self.data.tokens[loan.value.loan_token_id])
    with sp.if_((loan_token.value.type == TokenType.XTZ)):
        sp.verify(loan.value.loan_amount == sp.utils.mutez_to_nat(sp.amount), message = Error.ILLEGAL_TX_AMOUNT)
        sp.send(loan.value.borrower, sp.amount)
    with sp.else_():
        sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
        transfer_tokens(sender = sp.sender, receiver = loan.value.borrower, amount = loan.value.loan_amount, token = loan_token.value)
    self.data.ndeal += 1
    self.data.deals[self.data.ndeal] = sp.record(
        ts = sp.now,
        borrower = loan.value.borrower,
        creditor = sp.sender,
        loan_token_id = loan.value.loan_token_id,
        loan_amount = loan.value.loan_amount,
        reward = loan.value.reward,
        exp = sp.now.add_seconds(sp.to_int(loan.value.time)),
        deposit_token_id = loan.value.deposit_token_id,
        deposit_amount = loan.value.deposit_amount,
    )
    del self.data.loans[params.id]</code></pre>
</details>
</dd>
<dt id="contract.LendTez.close_deal"><code class="name flex">
<span>def <span class="ident">close_deal</span></span>(<span>self, params)</span>
</code></dt>
<dd>
<div class="desc"><p><em>Entrypoint</em>. Close a deal by borrower or creditor/admins.</p>
<p>If a deal is closed by borrower, the tokens are sent to the creditor and the borrower gets back the deposit;
if a deal timed out and it's closed by the creditor or admins, the creditor gets the deposit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong> :&ensp;<code>nat</code></dt>
<dd>credit deal ID</dd>
</dl>
<h2 id="raises">Raises</h2>
<p><code>OD_ILLEGAL_TX_AMOUNT</code>, <code>OD_ACCESS_DENIED</code>, <code>OD_ILLEGAL_ARGUMENT</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@sp.entry_point
def close_deal(self, params):
    &#34;&#34;&#34;Close a deal by borrower or creditor/admins.

    If a deal is closed by borrower, the tokens are sent to the creditor and the borrower gets back the deposit;
    if a deal timed out and it&#39;s closed by the creditor or admins, the creditor gets the deposit.

    Args:
        id (nat): credit deal ID
    Raises:
        `OD_ILLEGAL_TX_AMOUNT`, `OD_ACCESS_DENIED`, `OD_ILLEGAL_ARGUMENT`
    &#34;&#34;&#34;
    sp.set_type(params.id, sp.TNat)
    sp.verify(self.data.deals.contains(params.id), message = Error.ILLEGAL_ARGUMENT + &#34;:id&#34;)
    deal = sp.local(&#34;deal&#34;, self.data.deals[params.id])
    sp.verify((sp.sender == deal.value.borrower) | (sp.sender == deal.value.creditor) | self.data.admins.contains(sp.sender), Error.ACCESS_DENIED)
    deposit_receiver = sp.local(&#39;deposit_receiver&#39;, sp.self_address)
    with sp.if_(sp.sender == deal.value.borrower):
        loan_token = sp.local(&#34;loan_token&#34;, self.data.tokens[deal.value.loan_token_id])
        with sp.if_((loan_token.value.type == TokenType.XTZ)):
            sp.verify((deal.value.loan_amount + deal.value.reward) == sp.utils.mutez_to_nat(sp.amount), message = Error.ILLEGAL_TX_AMOUNT)
            sp.send(deal.value.creditor, sp.amount)
        with sp.else_():
            sp.verify(sp.amount == sp.mutez(0), message = Error.ILLEGAL_TX_AMOUNT)
            transfer_tokens(sender = deal.value.borrower, receiver = deal.value.creditor, amount = (deal.value.loan_amount + deal.value.reward), token = loan_token.value)
        deposit_receiver.value = deal.value.borrower
    with sp.else_():
        sp.verify(deal.value.exp &lt; sp.now, message = Error.ACCESS_DENIED)
        deposit_receiver.value = deal.value.creditor
    self.refund_deposit(receiver = deposit_receiver.value, token_id = deal.value.deposit_token_id, amount = deal.value.deposit_amount)
    del self.data.deals[params.id]</code></pre>
</details>
</dd>
<dt id="contract.LendTez.refund_deposit"><code class="name flex">
<span>def <span class="ident">refund_deposit</span></span>(<span>self, receiver, token_id, amount)</span>
</code></dt>
<dd>
<div class="desc"><p>Help function to send deposit.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>receiver</code></strong> :&ensp;<code>address</code></dt>
<dd>destination address</dd>
<dt><strong><code>token_id</code></strong> :&ensp;<code>nat</code></dt>
<dd>deposit token ID</dd>
<dt><strong><code>amount</code></strong> :&ensp;<code>nat</code></dt>
<dd>deposit amount of tokens</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refund_deposit(self, receiver, token_id, amount):
    &#34;&#34;&#34;Help function to send deposit.

    Args:
        receiver (address): destination address
        token_id (nat): deposit token ID
        amount (nat): deposit amount of tokens
    &#34;&#34;&#34;
    with sp.if_(amount &gt; 0):
        deposit_token = sp.local(&#34;deposit_token&#34;, self.data.tokens[token_id])
        with sp.if_((deposit_token.value.type == TokenType.XTZ)):
            sp.send(receiver, sp.utils.nat_to_mutez(amount))
        with sp.else_():
            transfer_tokens(sender = sp.self_address, receiver = receiver, amount = amount, token = deposit_token.value)
        self.data.tokens[token_id].locked_amount = sp.as_nat(self.data.tokens[token_id].locked_amount - amount)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="contract.transfer_tokens" href="#contract.transfer_tokens">transfer_tokens</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="contract.Error" href="#contract.Error">Error</a></code></h4>
<ul class="">
<li><code><a title="contract.Error.ACCESS_DENIED" href="#contract.Error.ACCESS_DENIED">ACCESS_DENIED</a></code></li>
<li><code><a title="contract.Error.ILLEGAL_ARGUMENT" href="#contract.Error.ILLEGAL_ARGUMENT">ILLEGAL_ARGUMENT</a></code></li>
<li><code><a title="contract.Error.ILLEGAL_TX_AMOUNT" href="#contract.Error.ILLEGAL_TX_AMOUNT">ILLEGAL_TX_AMOUNT</a></code></li>
<li><code><a title="contract.Error.PAUSED" href="#contract.Error.PAUSED">PAUSED</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="contract.TokenType" href="#contract.TokenType">TokenType</a></code></h4>
<ul class="">
<li><code><a title="contract.TokenType.XTZ" href="#contract.TokenType.XTZ">XTZ</a></code></li>
<li><code><a title="contract.TokenType.FA12" href="#contract.TokenType.FA12">FA12</a></code></li>
<li><code><a title="contract.TokenType.FA20" href="#contract.TokenType.FA20">FA20</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="contract.LendTez" href="#contract.LendTez">LendTez</a></code></h4>
<ul class="two-column">
<li><code><a title="contract.LendTez.default" href="#contract.LendTez.default">default</a></code></li>
<li><code><a title="contract.LendTez.withdraw" href="#contract.LendTez.withdraw">withdraw</a></code></li>
<li><code><a title="contract.LendTez.add_admin" href="#contract.LendTez.add_admin">add_admin</a></code></li>
<li><code><a title="contract.LendTez.remove_admin" href="#contract.LendTez.remove_admin">remove_admin</a></code></li>
<li><code><a title="contract.LendTez.delegate" href="#contract.LendTez.delegate">delegate</a></code></li>
<li><code><a title="contract.LendTez.pause" href="#contract.LendTez.pause">pause</a></code></li>
<li><code><a title="contract.LendTez.set_time" href="#contract.LendTez.set_time">set_time</a></code></li>
<li><code><a title="contract.LendTez.add_token" href="#contract.LendTez.add_token">add_token</a></code></li>
<li><code><a title="contract.LendTez.set_token_active" href="#contract.LendTez.set_token_active">set_token_active</a></code></li>
<li><code><a title="contract.LendTez.add_loan" href="#contract.LendTez.add_loan">add_loan</a></code></li>
<li><code><a title="contract.LendTez.cancel_loan" href="#contract.LendTez.cancel_loan">cancel_loan</a></code></li>
<li><code><a title="contract.LendTez.make_deal" href="#contract.LendTez.make_deal">make_deal</a></code></li>
<li><code><a title="contract.LendTez.close_deal" href="#contract.LendTez.close_deal">close_deal</a></code></li>
<li><code><a title="contract.LendTez.refund_deposit" href="#contract.LendTez.refund_deposit">refund_deposit</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>